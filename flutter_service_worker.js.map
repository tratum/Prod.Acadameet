{"mappings":"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","sources":["<anon>","flutter_service_worker.js"],"sourcesContent":["(() => {\n\"use strict\";\nconst $8df39a9bc6d9a464$var$MANIFEST = \"flutter-app-manifest\";\nconst $8df39a9bc6d9a464$var$TEMP = \"flutter-temp-cache\";\nconst $8df39a9bc6d9a464$var$CACHE_NAME = \"flutter-app-cache\";\nconst $8df39a9bc6d9a464$var$RESOURCES = {\n    \"canvaskit/canvaskit.js\": \"738255d00768497e86aa4ca510cce1e1\",\n    \"canvaskit/canvaskit.js.symbols\": \"74a84c23f5ada42fe063514c587968c6\",\n    \"canvaskit/canvaskit.wasm\": \"9251bb81ae8464c4df3b072f84aa969b\",\n    \"canvaskit/chromium/canvaskit.js\": \"901bb9e28fac643b7da75ecfd3339f3f\",\n    \"canvaskit/chromium/canvaskit.js.symbols\": \"ee7e331f7f5bbf5ec937737542112372\",\n    \"canvaskit/chromium/canvaskit.wasm\": \"399e2344480862e2dfa26f12fa5891d7\",\n    \"canvaskit/skwasm.js\": \"5d4f9263ec93efeb022bb14a3881d240\",\n    \"canvaskit/skwasm.js.symbols\": \"c3c05bd50bdf59da8626bbe446ce65a3\",\n    \"canvaskit/skwasm.wasm\": \"4051bfc27ba29bf420d17aa0c3a98bce\",\n    \"canvaskit/skwasm.worker.js\": \"bfb704a6c714a75da9ef320991e88b03\",\n    \"flutter.js\": \"383e55f7f3cce5be08fcf1f3881f585c\",\n    \"flutter_bootstrap.js\": \"60b3e4b088145a4193de74847659f570\",\n    \"index.html\": \"d8071c4cae838fa51c720e6562e6e20b\",\n    \"/\": \"d8071c4cae838fa51c720e6562e6e20b\",\n    \"main.dart.js\": \"f33ecdf7bea7c2d5b2d5e268ce43b8e1\",\n    \"version.json\": \"f3c5b0966b83a1e5db539ba4da355612\",\n    \"assets/assets/fonts/Outfit/Outfit-Regular.ttf\": \"9f444021dd670d995f9341982c396a1d\",\n    \"assets/assets/fonts/JosefinaSans/JosefinSans-Regular.ttf\": \"effd9508e574fd2ab338bbd81f784f3e\",\n    \"assets/fonts/MaterialIcons-Regular.otf\": \"1a09d0030a9d587b0f366776d6c1e24a\",\n    \"assets/shaders/ink_sparkle.frag\": \"ecc85a2e95f5e9f53123dcaf8cb9b6ce\",\n    \"assets/AssetManifest.json\": \"cdea625f853d16e6f8b386dde11eb36b\",\n    \"assets/AssetManifest.bin\": \"22d9ba7fae0d7d1e2e7ef0e3c804767e\",\n    \"assets/AssetManifest.bin.json\": \"af17769fd58f2e43f0ffac09c7788866\",\n    \"assets/FontManifest.json\": \"866980e490d319876020a49987d1dd30\",\n    \"assets/NOTICES\": \"e6cddce402e00bf9cc2c3c0fa32a59b1\",\n    \"favicon.png\": \"6c5380a6b5d5ed8b1526b34a1603cd63\",\n    \"icons/Icon-192.png\": \"d01a4a0da678b5fb801e703764f03d76\",\n    \"icons/Icon-512.png\": \"ba7188e9ed966ef235c6e66366b8e9d8\",\n    \"icons/Icon-maskable-192.png\": \"8e008a1b2572d6b7aeb8798bfdd8a4a3\",\n    \"icons/Icon-maskable-512.png\": \"58e64175f4c8c50566fdb44967573155\",\n    \"manifest.json\": \"c061c39dc89e2bc3026e6e96207b8843\",\n    \"manifestLoader.js\": \"36d27a14161e0c5378510320d5956b13\",\n    \"style.css\": \"5b96ebe50a979dad9e51687d5746c4bc\",\n    \"style.css.map\": \"c4dc242ff6bb2b8fbf2c5f404677ecac\",\n    \"manifestLoader.js.map\": \"7930cf9be7a5afa4483250c1572b0e6e\"\n};\n// The application shell files that are downloaded before a service worker can\n// start.\nconst $8df39a9bc6d9a464$var$CORE = [\n    \"main.dart.js\",\n    \"index.html\",\n    \"flutter_bootstrap.js\",\n    \"assets/AssetManifest.bin.json\",\n    \"assets/FontManifest.json\"\n];\n// During install, the TEMP cache is populated with the application shell files.\nself.addEventListener(\"install\", (event)=>{\n    self.skipWaiting();\n    return event.waitUntil(caches.open($8df39a9bc6d9a464$var$TEMP).then((cache)=>{\n        return cache.addAll($8df39a9bc6d9a464$var$CORE.map((value)=>new Request(value, {\n                \"cache\": \"reload\"\n            })));\n    }));\n});\n// During activate, the cache is populated with the temp files downloaded in\n// install. If this service worker is upgrading from one with a saved\n// MANIFEST, then use this to retain unchanged resource files.\nself.addEventListener(\"activate\", function(event) {\n    return event.waitUntil(async function() {\n        try {\n            var contentCache = await caches.open($8df39a9bc6d9a464$var$CACHE_NAME);\n            var tempCache = await caches.open($8df39a9bc6d9a464$var$TEMP);\n            var manifestCache = await caches.open($8df39a9bc6d9a464$var$MANIFEST);\n            var manifest = await manifestCache.match(\"manifest\");\n            // When there is no prior manifest, clear the entire cache.\n            if (!manifest) {\n                await caches.delete($8df39a9bc6d9a464$var$CACHE_NAME);\n                contentCache = await caches.open($8df39a9bc6d9a464$var$CACHE_NAME);\n                for (var request of (await tempCache.keys())){\n                    var response = await tempCache.match(request);\n                    await contentCache.put(request, response);\n                }\n                await caches.delete($8df39a9bc6d9a464$var$TEMP);\n                // Save the manifest to make future upgrades efficient.\n                await manifestCache.put(\"manifest\", new Response(JSON.stringify($8df39a9bc6d9a464$var$RESOURCES)));\n                // Claim client to enable caching on first launch\n                self.clients.claim();\n                return;\n            }\n            var oldManifest = await manifest.json();\n            var origin1 = self.location.origin;\n            for (var request of (await contentCache.keys())){\n                var key = request.url.substring(origin1.length + 1);\n                if (key == \"\") key = \"/\";\n                // If a resource from the old manifest is not in the new cache, or if\n                // the MD5 sum has changed, delete it. Otherwise the resource is left\n                // in the cache and can be reused by the new service worker.\n                if (!$8df39a9bc6d9a464$var$RESOURCES[key] || $8df39a9bc6d9a464$var$RESOURCES[key] != oldManifest[key]) await contentCache.delete(request);\n            }\n            // Populate the cache with the app shell TEMP files, potentially overwriting\n            // cache files preserved above.\n            for (var request of (await tempCache.keys())){\n                var response = await tempCache.match(request);\n                await contentCache.put(request, response);\n            }\n            await caches.delete($8df39a9bc6d9a464$var$TEMP);\n            // Save the manifest to make future upgrades efficient.\n            await manifestCache.put(\"manifest\", new Response(JSON.stringify($8df39a9bc6d9a464$var$RESOURCES)));\n            // Claim client to enable caching on first launch\n            self.clients.claim();\n            return;\n        } catch (err) {\n            // On an unhandled exception the state of the cache cannot be guaranteed.\n            console.error(\"Failed to upgrade service worker: \" + err);\n            await caches.delete($8df39a9bc6d9a464$var$CACHE_NAME);\n            await caches.delete($8df39a9bc6d9a464$var$TEMP);\n            await caches.delete($8df39a9bc6d9a464$var$MANIFEST);\n        }\n    }());\n});\n// The fetch handler redirects requests for RESOURCE files to the service\n// worker cache.\nself.addEventListener(\"fetch\", (event)=>{\n    if (event.request.method !== \"GET\") return;\n    var origin1 = self.location.origin;\n    var key = event.request.url.substring(origin1.length + 1);\n    // Redirect URLs to the index.html\n    if (key.indexOf(\"?v=\") != -1) key = key.split(\"?v=\")[0];\n    if (event.request.url == origin1 || event.request.url.startsWith(origin1 + \"/#\") || key == \"\") key = \"/\";\n    // If the URL is not the RESOURCE list then return to signal that the\n    // browser should take over.\n    if (!$8df39a9bc6d9a464$var$RESOURCES[key]) return;\n    // If the URL is the index.html, perform an online-first request.\n    if (key == \"/\") return $8df39a9bc6d9a464$var$onlineFirst(event);\n    event.respondWith(caches.open($8df39a9bc6d9a464$var$CACHE_NAME).then((cache)=>{\n        return cache.match(event.request).then((response)=>{\n            // Either respond with the cached resource, or perform a fetch and\n            // lazily populate the cache only if the resource was successfully fetched.\n            return response || fetch(event.request).then((response)=>{\n                if (response && Boolean(response.ok)) cache.put(event.request, response.clone());\n                return response;\n            });\n        });\n    }));\n});\nself.addEventListener(\"message\", (event)=>{\n    // SkipWaiting can be used to immediately activate a waiting service worker.\n    // This will also require a page refresh triggered by the main worker.\n    if (event.data === \"skipWaiting\") {\n        self.skipWaiting();\n        return;\n    }\n    if (event.data === \"downloadOffline\") {\n        $8df39a9bc6d9a464$var$downloadOffline();\n        return;\n    }\n});\n// Download offline will check the RESOURCES for all files not in the cache\n// and populate them.\nasync function $8df39a9bc6d9a464$var$downloadOffline() {\n    var resources = [];\n    var contentCache = await caches.open($8df39a9bc6d9a464$var$CACHE_NAME);\n    var currentContent = {};\n    for (var request of (await contentCache.keys())){\n        var key = request.url.substring(origin.length + 1);\n        if (key == \"\") key = \"/\";\n        currentContent[key] = true;\n    }\n    for (var resourceKey of Object.keys($8df39a9bc6d9a464$var$RESOURCES))if (!currentContent[resourceKey]) resources.push(resourceKey);\n    return contentCache.addAll(resources);\n}\n// Attempt to download the resource online before falling back to\n// the offline cache.\nfunction $8df39a9bc6d9a464$var$onlineFirst(event) {\n    return event.respondWith(fetch(event.request).then((response)=>{\n        return caches.open($8df39a9bc6d9a464$var$CACHE_NAME).then((cache)=>{\n            cache.put(event.request, response.clone());\n            return response;\n        });\n    }).catch((error)=>{\n        return caches.open($8df39a9bc6d9a464$var$CACHE_NAME).then((cache)=>{\n            return cache.match(event.request).then((response)=>{\n                if (response != null) return response;\n                throw error;\n            });\n        });\n    }));\n}\n\n})();\n//# sourceMappingURL=flutter_service_worker.js.map\n","'use strict';\nconst MANIFEST = 'flutter-app-manifest';\nconst TEMP = 'flutter-temp-cache';\nconst CACHE_NAME = 'flutter-app-cache';\n\nconst RESOURCES = {\"canvaskit/canvaskit.js\": \"738255d00768497e86aa4ca510cce1e1\",\n\"canvaskit/canvaskit.js.symbols\": \"74a84c23f5ada42fe063514c587968c6\",\n\"canvaskit/canvaskit.wasm\": \"9251bb81ae8464c4df3b072f84aa969b\",\n\"canvaskit/chromium/canvaskit.js\": \"901bb9e28fac643b7da75ecfd3339f3f\",\n\"canvaskit/chromium/canvaskit.js.symbols\": \"ee7e331f7f5bbf5ec937737542112372\",\n\"canvaskit/chromium/canvaskit.wasm\": \"399e2344480862e2dfa26f12fa5891d7\",\n\"canvaskit/skwasm.js\": \"5d4f9263ec93efeb022bb14a3881d240\",\n\"canvaskit/skwasm.js.symbols\": \"c3c05bd50bdf59da8626bbe446ce65a3\",\n\"canvaskit/skwasm.wasm\": \"4051bfc27ba29bf420d17aa0c3a98bce\",\n\"canvaskit/skwasm.worker.js\": \"bfb704a6c714a75da9ef320991e88b03\",\n\"flutter.js\": \"383e55f7f3cce5be08fcf1f3881f585c\",\n\"flutter_bootstrap.js\": \"60b3e4b088145a4193de74847659f570\",\n\"index.html\": \"d8071c4cae838fa51c720e6562e6e20b\",\n\"/\": \"d8071c4cae838fa51c720e6562e6e20b\",\n\"main.dart.js\": \"f33ecdf7bea7c2d5b2d5e268ce43b8e1\",\n\"version.json\": \"f3c5b0966b83a1e5db539ba4da355612\",\n\"assets/assets/fonts/Outfit/Outfit-Regular.ttf\": \"9f444021dd670d995f9341982c396a1d\",\n\"assets/assets/fonts/JosefinaSans/JosefinSans-Regular.ttf\": \"effd9508e574fd2ab338bbd81f784f3e\",\n\"assets/fonts/MaterialIcons-Regular.otf\": \"1a09d0030a9d587b0f366776d6c1e24a\",\n\"assets/shaders/ink_sparkle.frag\": \"ecc85a2e95f5e9f53123dcaf8cb9b6ce\",\n\"assets/AssetManifest.json\": \"cdea625f853d16e6f8b386dde11eb36b\",\n\"assets/AssetManifest.bin\": \"22d9ba7fae0d7d1e2e7ef0e3c804767e\",\n\"assets/AssetManifest.bin.json\": \"af17769fd58f2e43f0ffac09c7788866\",\n\"assets/FontManifest.json\": \"866980e490d319876020a49987d1dd30\",\n\"assets/NOTICES\": \"e6cddce402e00bf9cc2c3c0fa32a59b1\",\n\"favicon.png\": \"6c5380a6b5d5ed8b1526b34a1603cd63\",\n\"icons/Icon-192.png\": \"d01a4a0da678b5fb801e703764f03d76\",\n\"icons/Icon-512.png\": \"ba7188e9ed966ef235c6e66366b8e9d8\",\n\"icons/Icon-maskable-192.png\": \"8e008a1b2572d6b7aeb8798bfdd8a4a3\",\n\"icons/Icon-maskable-512.png\": \"58e64175f4c8c50566fdb44967573155\",\n\"manifest.json\": \"c061c39dc89e2bc3026e6e96207b8843\",\n\"manifestLoader.js\": \"36d27a14161e0c5378510320d5956b13\",\n\"style.css\": \"5b96ebe50a979dad9e51687d5746c4bc\",\n\"style.css.map\": \"c4dc242ff6bb2b8fbf2c5f404677ecac\",\n\"manifestLoader.js.map\": \"7930cf9be7a5afa4483250c1572b0e6e\"};\n// The application shell files that are downloaded before a service worker can\n// start.\nconst CORE = [\"main.dart.js\",\n\"index.html\",\n\"flutter_bootstrap.js\",\n\"assets/AssetManifest.bin.json\",\n\"assets/FontManifest.json\"];\n\n// During install, the TEMP cache is populated with the application shell files.\nself.addEventListener(\"install\", (event) => {\n  self.skipWaiting();\n  return event.waitUntil(\n    caches.open(TEMP).then((cache) => {\n      return cache.addAll(\n        CORE.map((value) => new Request(value, {'cache': 'reload'})));\n    })\n  );\n});\n// During activate, the cache is populated with the temp files downloaded in\n// install. If this service worker is upgrading from one with a saved\n// MANIFEST, then use this to retain unchanged resource files.\nself.addEventListener(\"activate\", function(event) {\n  return event.waitUntil(async function() {\n    try {\n      var contentCache = await caches.open(CACHE_NAME);\n      var tempCache = await caches.open(TEMP);\n      var manifestCache = await caches.open(MANIFEST);\n      var manifest = await manifestCache.match('manifest');\n      // When there is no prior manifest, clear the entire cache.\n      if (!manifest) {\n        await caches.delete(CACHE_NAME);\n        contentCache = await caches.open(CACHE_NAME);\n        for (var request of await tempCache.keys()) {\n          var response = await tempCache.match(request);\n          await contentCache.put(request, response);\n        }\n        await caches.delete(TEMP);\n        // Save the manifest to make future upgrades efficient.\n        await manifestCache.put('manifest', new Response(JSON.stringify(RESOURCES)));\n        // Claim client to enable caching on first launch\n        self.clients.claim();\n        return;\n      }\n      var oldManifest = await manifest.json();\n      var origin = self.location.origin;\n      for (var request of await contentCache.keys()) {\n        var key = request.url.substring(origin.length + 1);\n        if (key == \"\") {\n          key = \"/\";\n        }\n        // If a resource from the old manifest is not in the new cache, or if\n        // the MD5 sum has changed, delete it. Otherwise the resource is left\n        // in the cache and can be reused by the new service worker.\n        if (!RESOURCES[key] || RESOURCES[key] != oldManifest[key]) {\n          await contentCache.delete(request);\n        }\n      }\n      // Populate the cache with the app shell TEMP files, potentially overwriting\n      // cache files preserved above.\n      for (var request of await tempCache.keys()) {\n        var response = await tempCache.match(request);\n        await contentCache.put(request, response);\n      }\n      await caches.delete(TEMP);\n      // Save the manifest to make future upgrades efficient.\n      await manifestCache.put('manifest', new Response(JSON.stringify(RESOURCES)));\n      // Claim client to enable caching on first launch\n      self.clients.claim();\n      return;\n    } catch (err) {\n      // On an unhandled exception the state of the cache cannot be guaranteed.\n      console.error('Failed to upgrade service worker: ' + err);\n      await caches.delete(CACHE_NAME);\n      await caches.delete(TEMP);\n      await caches.delete(MANIFEST);\n    }\n  }());\n});\n// The fetch handler redirects requests for RESOURCE files to the service\n// worker cache.\nself.addEventListener(\"fetch\", (event) => {\n  if (event.request.method !== 'GET') {\n    return;\n  }\n  var origin = self.location.origin;\n  var key = event.request.url.substring(origin.length + 1);\n  // Redirect URLs to the index.html\n  if (key.indexOf('?v=') != -1) {\n    key = key.split('?v=')[0];\n  }\n  if (event.request.url == origin || event.request.url.startsWith(origin + '/#') || key == '') {\n    key = '/';\n  }\n  // If the URL is not the RESOURCE list then return to signal that the\n  // browser should take over.\n  if (!RESOURCES[key]) {\n    return;\n  }\n  // If the URL is the index.html, perform an online-first request.\n  if (key == '/') {\n    return onlineFirst(event);\n  }\n  event.respondWith(caches.open(CACHE_NAME)\n    .then((cache) =>  {\n      return cache.match(event.request).then((response) => {\n        // Either respond with the cached resource, or perform a fetch and\n        // lazily populate the cache only if the resource was successfully fetched.\n        return response || fetch(event.request).then((response) => {\n          if (response && Boolean(response.ok)) {\n            cache.put(event.request, response.clone());\n          }\n          return response;\n        });\n      })\n    })\n  );\n});\nself.addEventListener('message', (event) => {\n  // SkipWaiting can be used to immediately activate a waiting service worker.\n  // This will also require a page refresh triggered by the main worker.\n  if (event.data === 'skipWaiting') {\n    self.skipWaiting();\n    return;\n  }\n  if (event.data === 'downloadOffline') {\n    downloadOffline();\n    return;\n  }\n});\n// Download offline will check the RESOURCES for all files not in the cache\n// and populate them.\nasync function downloadOffline() {\n  var resources = [];\n  var contentCache = await caches.open(CACHE_NAME);\n  var currentContent = {};\n  for (var request of await contentCache.keys()) {\n    var key = request.url.substring(origin.length + 1);\n    if (key == \"\") {\n      key = \"/\";\n    }\n    currentContent[key] = true;\n  }\n  for (var resourceKey of Object.keys(RESOURCES)) {\n    if (!currentContent[resourceKey]) {\n      resources.push(resourceKey);\n    }\n  }\n  return contentCache.addAll(resources);\n}\n// Attempt to download the resource online before falling back to\n// the offline cache.\nfunction onlineFirst(event) {\n  return event.respondWith(\n    fetch(event.request).then((response) => {\n      return caches.open(CACHE_NAME).then((cache) => {\n        cache.put(event.request, response.clone());\n        return response;\n      });\n    }).catch((error) => {\n      return caches.open(CACHE_NAME).then((cache) => {\n        return cache.match(event.request).then((response) => {\n          if (response != null) {\n            return response;\n          }\n          throw error;\n        });\n      });\n    })\n  );\n}\n"],"names":["$8df39a9bc6d9a464$var$MANIFEST","$8df39a9bc6d9a464$var$TEMP","$8df39a9bc6d9a464$var$CACHE_NAME","$8df39a9bc6d9a464$var$RESOURCES","$8df39a9bc6d9a464$var$CORE","$8df39a9bc6d9a464$var$downloadOffline","resources","contentCache","caches","open","currentContent","request","keys","key","url","substring","origin","length","resourceKey","Object","push","addAll","self","addEventListener","event","skipWaiting","waitUntil","then","cache","map","value","Request","tempCache","manifestCache","manifest","match","delete","response","put","Response","JSON","stringify","clients","claim","oldManifest","json","origin1","location","err","console","error","method","indexOf","split","startsWith","respondWith","fetch","clone","catch","ok","data"],"version":3,"file":"flutter_service_worker.js.map"}